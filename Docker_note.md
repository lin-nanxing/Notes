# Docker笔记记录(个人向)
### 1. 简介
  - `Docker`是一个用于**构建**`build`、**运行**`run`和**传送**`share`应用程序的平台。
  - 它可以帮助我们将应用程序**打包**成一个个标准化的"箱子"，再运送到任何需要的设备中。
  - `Docker`可以使应用程序和它运行所需要的各种依赖包、第三方软件库、配置文件等打包在一起，**以便在任何环境内应用程序都可以正确地运行**
  - > Q : 为什么要用`Docker`运输应用程序呢？
    > A : 例如我们要搭建的一个网站，采用**前后端分离机构**。前端用流行的`Vue`框架来构建界面，后端用`Java`的`SpringBoot`微服务框架来提供各种服务和接口，然后使用`MySQL`来存储数据。那么我们需要：        
    > 1. 安装`NodeJS`环境
    > 2. 安装各种`npm`运行所需要的依赖包
    > 3. 安装`Java`运行所需要的环境
    > 4. 安装各种第三方的依赖包(如`SpringBoot`微服务依赖包)
    > 5. 安装`MySQL`数据库
    > 6. 配置环境变量`PATH`，启动脚本服务
    > 7. 安装配置`Redis`缓存
    > 8. 安装配置`Nginx`负载均衡
    > 9. ……
    > 而通过`Docker`，我们可以把上述的安装配置标准化分割再打包，就可以顺利的把开发环境的内容迁移到测试环境，不需要担心出错和浪费时间。
  - > Q : `Docker`和虚拟机之间的区别
    > A : 虚拟机是通过`虚拟化`技术来实现的。`虚拟化`即**将物理资源虚拟化成多个逻辑资源**，将一台物理服务器虚拟成多个逻辑服务器(可以运行不同的操作系统和使用着不同的数据)的技术。这些不同的逻辑服务器彼此之间是**相互隔离**的，可以**独立运行**。虚拟机从某种程度上实现了服务器的整合，可以将一台服务器的资源充分利用，用一套设备实现多台服务器的功能。但是受制于硬件条件，这些虚拟机往往运行速度不快，启动也相当慢，通常需要几分钟甚至几十分钟的时间。
    > ![g17](/jpg/g17.png)
    > 而对于`Docker`的主要实现思路`容器化`来说(`Docker`其实是容器化技术的一种解决方案和平台)，
    > ![g18](/jpg/g18.png)
    > `容器化`不用安装另外的操作系统，只需要使用原来的操作系统运行部分对应功能即可，故占用更少资源、**效率大大提高**，且**支持更多的容器`Container`同开**。
### 2. 基本原理和概念
 - `Docker`主要用到**镜像**、**容器**和**仓库**这几种元素。
 1. **镜像**是一个只读的模板，它可以用来创建**容器**
 2. **容器**是`Docker`的**运行实例**，它提供了一个独立可移植的环境，我们可以在这个环境中运行应用程序。
    > 镜像和容器的关系就像是`Java`和`C++`中的类和实例的关系一样。
    > ![g19](/jpg/g19.png)
 3. **仓库**是用来存储`Docker`镜像的地方。最流行和最常用的仓库就是`Dockerhub`。它是一个公共的`Docker`仓库，用来集中存储和管理`Docker`镜像，类似于存放项目和文件的`Github`。我们可以在这里下载和上传自己或他人的镜像文件。
- `Docker`使用`Client-Sever`架构模式，`Docker Client`和`Docker Daemon`之间通过`Socket`或者`RESTful API`进行通信。
- `Docker Daemon`就是服务端的**守护进程**，它负责管理`Docker`的各种资源。
- `Docker Client`负责向`Docker Daemon`发送请求，后者接收到请求之后进行处理，将结果发还给`Docket Client`。此时，`Docker Daemon`作为一个后台进程，用来接收并处理来自于`Docker`客户端的请求，将结果返回给客户端，然后就可以在终端中看到执行结果了。
### 3. Docker的安装配置
  1. 在[Docker官网](www.docker.com)下载安装包然后双击安装即可
  2. **安装完毕之后记得启动`Docker`**，否则之后的操作将无法进行
  3. `Windows`要启动`Docker`，需要先打开设置`Settings`，搜索`Hyper`找到`启用或关闭Windows功能`点击，勾选`Hyper-V`之后按照提示重启电脑就可以打开`Hyper-V`功能。这个功能是`Docker`运行的前提。
  4. `Docker`启动之后，会在状态栏(右下角)看到一个小鲸鱼的图标，这是`Docker`的图标，显示已经启动了。
  5. 启动之后，可以在终端或者`shell`中使用`Docker`的各种命令了
### 4. Docker常见命令
- `docker version`：查看Docker的版本信息
    > 一般情况下能同时看到`Client`和`Server`。如果你只看到`Client`说明你的`Docker`没有启动，只有启动后才能看到。
- `docker info`: 查看docker系统信息
- `docker [command] --help`: 查看`Docker`帮助文档
- `docker login\logout`: 登录\退出`DockerHub`
### 5. 容器化
- 即`containerization`，顾名思义就是将应用程序打包成容器，然后在容器中运行应用程序的过程。
- 对应用程序的容器化分为以下步骤：
  1. 创建一个`Dockerfile`,来告诉`Docker`构建应用程序镜像。
  2. 使用`Dockerfile`构建镜像
  3. 使用镜像创建和运行容器     
  > `Dockerfile`是一类文本文件，里面包含了一条条的指令。指令用来`Docker`如何来构建镜像。这个镜像中包含我们应用程序的所有命令(各种依赖、配置环境、运行应用程序所需要的内容).一般来说，**我们会在项目的根目录下创建叫`Dockerfile`文件**，用于在这个文件中写入所需要的各种指令。
- 如何编写`Docker`？        
    1. 新建文件夹，命名与`Docker`相关
    2. 编辑器打开文件夹，创建`index.js`的文件，在文件中输入`console.log("文本内容")`，可以在终端中输入`node index.js`打开
        > `NodeJS`是一个运行时环境，它可以让我们在浏览器之外的地方运行`Javascript`的代码
    3. 创建`Dockerfile`(无拓展名),把运行步骤(程序)写入到`Dockerfile`中：        
        > 1. 先指定一个基础镜像，例如先指定一个操作系统镜像，如`FROM node:14-alpine`，其中14是版本号，`alpine`是`Linux`轻量级发行版的名称。毕竟**镜像是按层次结构来构建的**
        > 2. 将应用程序复制或导入文件中，可以用`COPY source dest`的格式完成复制。其中的`source`是应用程序名，在根目录中相对于`Dockerfile`的地址
        > 3. `CMD["可执行程序的名字","可执行程序接收到的应用程序"]` 或者 `CMD 可执行程序名 应用程序地址`
        > 4. 接着我们可以用`docker image ls`查看根目录中的镜像信息
        > 5. 
        > 6. 用`docker run 应用程序名`的方法测试运行镜像文件
    4. 剩下的工作交给`Docker`来自动完成
 - 推荐一个网站来不断实践：[Docker With you](https://labs.play-with-docker.com/)

### 6. Docker Destop\*
- 是`Docker`的一种常见的**图形化界面**
- 封装了容器`Container`日常使用和管理的各种常用功能
- 打开控制面板之后，就能在左上角菜单中看到容器和镜像。我们构建的镜像在镜像中查看
- 要想和远程仓库之间建立关联，先得在右上角的头像位置点击并登录个人账号。
- 菜单中的`Volumes`意指**逻辑卷**。逻辑卷用于存储`Docker`中的数据。
  > `Docker`中的数据有一个特点：**容器中的数据是不会持久化的**。在容器开始之后，卷会录入数据，但当容器停止之后，所有数据都会丢失掉。
  
  而为了能保留这部分数据，我们需要**逻辑卷**将容器中的目录或者指定路径映射到宿主机的某一个目录或者位置上。这样就可以将数据保存在宿主机的磁盘上，实现数据的持久化。
- `Dev Environments`用于管理开发环境。我们可以在这里创建一个开发环境，并用一些代码来配置这个开发环境。这个开发环境可以共享给项目中的其他开发人员。所有人在一个开发环境，可以避免因为环境的不一致导致的各种问题和`bugs`。

### 7. Docker Compose
- 由`Docker`官方主导的开源项目
- 用于定义和运行多容器`Docker`应用程序的工具
- 通过`docker-compose.yaml`文件来配置应用程序的服务(打通多个独立服务器之间的关联关系),使项目中的一组互相关联的装有应用程序的容器组合在一起。
- 只用一条命令即可创建并启动、停止所有服务，如`docker compose up`。